module circular_shift (
    input clk,  // clock
    input rst,  // reset
    input position[16], //
    input n[4], // number of bits to shift by
    input dir, // left or right shift, 0 == left, 1 == right
    output out[16]
  ) {
  
    .clk(clk){
  
    // define dffs needed
    dff pos[16];
    
    .rst(rst){
    }
    
    //fsm lr = {INIT, CSHL, CSHR};
  }

  always {
  
    pos.d = position;
  
    // CSHL
    if (dir == 0) {
      // CSHL
      pos.d[15:0] = pos.q << 5;
    }
    
    // CSHL (SPECIAL)
    if (pos.q[15:0] == 16b0) {
        pos.d = 1;
    }
      
    //out = pos.q;
    
    
    
    // CSHR
    if (dir == 1) {
    
      // CSHL
      pos.d[15:0] = position >> 5;
    }
    
    // CSHL (SPECIAL)
    if (pos.q[15:0] == 16b0) {
        pos.d = 16h8000;
    }      
      
    //out = pos.q;
      

    
    out = pos.q;
    
    
    
    /*
    case(lr.q){
    
      lr.INIT:
        if (direction == 0) {
          lr.d = lr.CSHL;
        }
        if (direction == 1) {
          lr.d = lr.CSHR;
        }
        
      lr.CSHL:
        pos.d = pos.q << n;
        
        if (pos.q[15:0] == 16b0) {
            pos.d = 16b1;
        }
        
        out = pos.q;
        
      lr.CSHR:
        pos.d = pos.q >> n;
        
        if (pos.q[15:0] == 16b0) {
            pos.d = 16h8000;
        }
        
        out = pos.q;
      } 
    */
  }
}
